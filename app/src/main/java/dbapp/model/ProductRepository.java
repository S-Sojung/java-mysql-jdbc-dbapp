/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package dbapp.model;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;

import com.mysql.cj.protocol.Resultset;

public class ProductRepository {
    // DI 주입 받음
    private Connection conn;

    public ProductRepository(Connection conn) {
        this.conn = conn;
    }

    public void insert(String name, int price, int qty) throws SQLException {
        // 워크벤치나 여기는 모두 DBMS 에 접근 하는 툴

        // 2. 버퍼 접근
        String sql = "insert into product (name, price, qty, created_at) values(?,?,?,now())";
        PreparedStatement pstmt = conn.prepareStatement(sql);
        // 얘가 알아서 값으로 들어오면 안되는 or, and, --(주석) 같은것들을(insection 공격) 알아서 막아서 exception 을
        // 터트려준다

        // 3. 물음표 완성
        pstmt.setString(1, name); // 1 부터 시작
        pstmt.setInt(2, price);
        pstmt.setInt(3, qty);

        // 4. 전송
        int result = pstmt.executeUpdate();// return int
        // pstmt.executeQuery();// return resultset

        // 5. 응답에 대한 처리
        if (result == 1) {
            System.out.println("insert 되었습니다.");
        } else {
            System.out.println("insert 실패.");
        }

        // 6. 마무리 (연결된 객체 끊기 / 커넥션 풀링 기능을 쓰면 알아서 끊김)
        // conn.close(); // 하지만 어처피 메인이 끝나면 알아서 끝남 힙에 띄우는 거면 종료 시켜줘야함
        pstmt.close();
    }

    public void deleteById(int id) throws SQLException {

        // 2. 버퍼 접근
        String sql = "delete from product where id = ?";
        PreparedStatement pstmt = conn.prepareStatement(sql);
        // 3. 물음표 완성
        pstmt.setInt(1, id); // 1 부터 시작
        // 4. 전송
        int result = pstmt.executeUpdate();

        // 5. 응답에 대한 처리
        if (result == 1) {
            System.out.println("delete 되었습니다.");
        } else {
            System.out.println("delete 실패.");
        }

        pstmt.close();
    }

    public void updateById(int id, String name, int price, int qty) throws SQLException {

        // 2. 버퍼 접근
        String sql = "update product set name=?, price=?, qty=? where id = ?";
        PreparedStatement pstmt = conn.prepareStatement(sql);
        // 3. 물음표 완성
        pstmt.setString(1, name); // 1 부터 시작
        pstmt.setInt(2, price); // 1 부터 시작
        pstmt.setInt(3, qty); // 1 부터 시작
        pstmt.setInt(4, id); // 1 부터 시작
        // 4. 전송
        int result = pstmt.executeUpdate();

        // 5. 응답에 대한 처리
        if (result == 1) {
            System.out.println("update 되었습니다.");
        } else {
            System.out.println("update 실패.");
        }

        pstmt.close();
    }

    public Product findById(int id) throws SQLException {
        // 1. 리턴할 객체 정의
        Product product = null;

        // 2. 버퍼 접근
        String sql = "select * from product where id =?";
        PreparedStatement pstmt = conn.prepareStatement(sql);
        // 3. 물음표 완성
        pstmt.setInt(1, id); // 1 부터 시작

        // 4. 전송
        ResultSet rs = pstmt.executeQuery();
        // 맨 첫줄은 컬럼명줄이기 때문에 한 줄을 꼭 내려줘야한다.

        if (rs.next()) {
            int v1 = rs.getInt("id");
            String name = rs.getString("name");
            int price = rs.getInt("price");
            int qty = rs.getInt("qty");
            Timestamp createdAt = rs.getTimestamp("created_at");
            product = new Product(v1, name, price, qty, createdAt);
            // mybatis가 이걸 매핑해서 해줌 ..... 알아서!
        }
        return product;
    }

    public List<Product> findAll() throws SQLException {
        // 1. 리턴할 객체 정의
        List<Product> productList = new ArrayList<>();
        // 2. 버퍼 접근
        String sql = "select * from product";
        PreparedStatement pstmt = conn.prepareStatement(sql);

        // 4. 전송
        ResultSet rs = pstmt.executeQuery();

        while (rs.next()) {
            int id = rs.getInt("id");
            String name = rs.getString("name");
            int price = rs.getInt("price");
            int qty = rs.getInt("qty");
            Timestamp createdAt = rs.getTimestamp("created_at");
            Product product = new Product(id, name, price, qty, createdAt);
            productList.add(product);
        }
        return productList;
    }
}
